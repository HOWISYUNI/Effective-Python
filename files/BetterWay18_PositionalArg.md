## Better Way 18. 가변 위치 인수로 깔끔하게 보이게 하자

#### 72쪽

* Created : 2016/09/03  
* Modified: 2019/05/15  

* 18, 19, 21장에서는 그 유명한 Packing과 Unpacking에 대해 다룬다.  


<br>


## 1. 임의의 개수를 받는 위치 인수 사용법

**함수에서 선택적인 위치 인수(positional arguments, 함수 정의에서 _\*args_ 와 같은 변수명을 사용)를 받게 만들면 함수 호출을 더 명확하게 할 수 있고 보기에 방해가 되는 요소를 없앨 수 있다.**

먼저 위치 인수를 사용하지 않는 간단한 사용함수를 만들어보자.

디버그 정보 몇 개를 로그에 남기는 함수를 만든다고 하자. 인수의 개수가 고정되어 있다면 메시지와 값
리스트를 받는 함수를 만든다고 할 수 있다.

```python
def log(message, values):
    if not values:
        print(message)
    else:
        joined_values = ', '.join(str(v) for v in values)
        print(message + ': ', joined_values)


>>> log('My numbers are', [1, 2])
>>> log('반갑소 제군들', [])

My numbers are: 1, 2
반갑소 제군들
```

잘 작동한다만 두 번째 사용예처럼 로그에 남길 값이 없을 때 빈값을 넘기는 것은 불편한 일이다. 또한
남길 값이 한 개가 아닌, 두 개, 세 개, 수천만 개일 수도 있지 않은가? 지금 저 로그 함수는 그런
입력들에 대해 대응하지 못한다.

이때 선택적 위치 인수를 사용한다. 함수 정의에서 위치 인수 Packing을 사용하면 입력들의 임의의 개수에
대해 적절하게 반응할 수 있다.

```python
def log(message, *values): # !!!
    if not values:
        print(message)
    else:
        joined_values = ', '.join(str(v) for v in values)
        print(message + ': ', joined_values)


>>> log('My numbers are', [1, 2])
>>> log('My numbers are', 1, 2)
>>> log('반갑소 제군들')

My numbers are: 1, 2
My numbers are: 1, 2
반갑소 제군들
```

아까의 로그 함수와 거의 비슷한데 다만, _message_ 변수 이후에 **임의의 개수의 입력에 대해 모두 적절하게 반응할 수 있도록 '\*'를 사용해 Packing을 지시했다.**

이를 통해서 세 번째 예처럼 _message_ 이후에 0개의 입력을 주는 것은 물론, 두 번째처럼 두 개의 개수의
변수를 입력해도 문제없이 작동했다.

<br>

이런 위치 인수를 사용하도록 정의된 함수에서는, 다시 말해 임의의 개수의 인자를 하나의 개수로
Packing하는 함수는 실행할 때 어떻게 사용할까? 만약 **입력이 Iterable이라면 실행 시에 인자에 '\*'를 붙여줘서 Unpacking하면 된다.**

```python
log('test1', 1, 2, 3)
log('test2', *['a', 'b', 'c', 'd', 'e'])  # !!
log('test3', 1, 2, *['가', '나', '다'])   # !!


test1:  1, 2, 3
test2:  a, b, c, d, e
test3:  1, 2, 가, 나, 다
```

앞서 _log_ 함수 정의에서는 첫 인자를 제외한 다른 모든 입력 인자들을 하나의 단일 인자로 합쳤다.(Packed) 이때 합친 인자의 타입은 _tuple_ 이 된다. 이 함수를 사용할 때는 리스트처럼 이미 합쳐진 인자라면 펼친 채로 입력하면 로그 함수가 알아서 합쳐서 잘 실행할 것이다. 따라서 실행 시에는 '\*'를 써서 인자를 풀어준다.(Unpacked)

이게 Packing과 Unpacking의 핵심으로 이것만 이해하면 향후 다룰 키워드 전용 인자도 문제없다.


<Br>


## 2. 선택적 위치 인자 사용의 단점

앞서 살펴본 Packing과 Unpacking을 통해 자바 등의 언어에서 지원하는 메소드 오버로딩을 파이썬에서
어떻게 지원하는지 알 수 있었다. 다만 이 사용법에는 두 가지 주요 문제가 있다.


### 2.1. 메모리 고갈의 문제점  


함수 정의 시에 Packing을 사용하면 입력을 하나의 튜플로 묶으며, 사용 시에 Unpacking을 사용하면 Iterable한 입력을 풀어헤친다는 것을 살폈다. 여기서 문제가 되는 것은 Unpacking이다. **함수를 호출하는 쪽에서 제너레이터에 '\*' 연산자를 쓰면 제너레이터가 모두 소진될 때까지 순회해서 튜플을 만든다는 뜻이 되기 때문에, 결과로 생성되는 튜플은 메모리를 너무 많이 차지해 프로그램이 망가질 수 있다.**

```python
def my_generator():
    for i in range(10):
        yield i

def my_func(*args):
    type(args)


it = my_generator()
>>> my_func(*it)

(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
```

**\*args를 받는 함수는 인수 리스트에 있는 입력의 수가 적당히 적다는 사실을 아는 상황에서 가장 좋은 방법이다.** 이런 함수는 많은 리터럴이나 변수 이름을 한꺼번에 넘기는 함수 호출에 이상적이다. 주로 개발자들을 편하게 하고, 가독성을 높이려고 사용한다.

### 2.2. 기능 확장 시에 디버깅의 어려움

두 번째 문제는 선택적 위치 인수를 사용해 정의한 기능을 확장할 때 생기는 문제점이다. 일반적으로, 원래의 기능 정의를 확장한다면 그 기능을 사용하는 이전 호출코드는 문제없이 사용되기를 바랄 것이다. 즉 새 기능은 이전 기능을 문제없이 포함할 수 있어야 한다.

다만 문제가 되는 것은 **기능에 새 위치 인수를 추가하고 싶을 때에는 추후에 호출 코드를 모두 변경해야 한다는 점이다.** 함수 인자 목록 앞쪽에 위치 인자를 추가하면, 기존의 호출 코드가 수정 없이는 정상적으로 동작하지 않는다.  

기존의 로그 함수에서 메시지와 값에 추가로 로그의 코드 번호를 추가한다고 하자. 이는 HTTP response의 status code와 같은 역할을 생각하면 될 것이다.

```python
def log(code, message, *values):
    if not values:
        print('{} / {}'.format(code, message))
    else:
        values_str = ', '.join(str(x) for x in values)
        print('{} / {}: {}'.format(code, message, values_str))

>>> log(200, 'favorites', 7,33) # 1.
>>> log('Favorite', 7, 33)      # 2.


200 / favorites: 7, 33  
Favorite / 7: 33
```

1. 확장된 기능에 맞게 함수를 호출한 로그 함수에서는 의도대로 결과물이 출력됐다.
1. 두 번째 호출은 이전 호출 코드를 그대로 가져온 것인데 출력이 의도대로 나오지 않았다.

이런 문제가 발생한 이유는 두 번째 호출이 _code_ 인수를 받지 못했기 때문에 'Favorite'를 _code_ 로, 7을 _message_ 로 사용했다는 점이다. **이런 버그는 코드에서 예외를 일으키지 않고 계속 실행되기 때문에 발견하기가 극히 어렵다. 이런 문제가 생길 가능성을 없애려면 _\*args_ 를 받는 함수를 확장할 때 키워드 전용(keyword only) 인수를 사용하는 것이다. 이는 21장에서 다룰 것이다.**

<br>

## 3. 핵심 정리

* def 문에서 \*args를 사용하면 함수에서 가변 개수의 위치 인수를 받을 수 있다.
* \* 연산자를 쓰면 시퀀스에 들어 있는 아이템을 함수의 위치 인수로 사용할 수 있다.
* 제너레이터와 \* 연산자를 함께 사용하면 프로그램이 메모리 부족으로 망가질 수 있다.
* \*args를 받는 함수에 새 위치 파라미터를 추가하면 정말 찾기 어려운 버그가 생길 수도 있다.
