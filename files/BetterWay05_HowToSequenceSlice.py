# Better way 5. 시퀀스를 슬라이스하는 방법을 알자.
# 28쪽
# 작성 일자 : 16/12/25

##################################################

"""
파이썬은 다른 프로그래밍 언어와 마찬가지로 리스트 등의 시퀀스를 슬라이스해서
조각으로 만드는 문법을 제공한다. 이를 통해 시퀀스의 부분집합을 쉽게 구할 수 있다.

간단한 시퀀스의 예로는 list], str, bytes가 있을 것이다.
__getitem__과 __setitem__이라는 특별한 메소드를 구현하는 파이썬의 클래스에도
슬라이싱을 적용할 수 있다.

슬라이스의 기본 형태는 somelist[start:end]이다. 여타 언어와 같이
start는 포함되고] end는 제외된다.
"""

a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',]

print('First four', a[:4])      # ['a', 'b', 'c', 'd']
print('Last four', a[:-4])      # ['e', 'f', 'g', 'h']
print('Middle two', a[3:-3])    # ['d', 'e']

# 리스트의 처음부터 슬라이스할 때는 보기 편하게 인덱스 0을 생략한다.
# 리스트의 끝까지 슬라이스 할 때도 마지막 인덱스는 넣지 않아도 된다.

# 리스트의 끝을 기준으로 계산할 때는 음수로 슬라이스하는 게 편하다.
# 그 의미가 분명하고 간결하므로 이런 슬라이스 형태를 사용하기 바란다.


a[:]        # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
a[:5]       # ['a', 'b', 'c', 'd', 'e']
a[:-1]      # ['a', 'b', 'c', 'd', 'e', 'f', 'g']
a[4:]       #                     ['e', 'f', 'g', 'h']
a[-3:]      #                          ['f', 'g', 'h']
a[2:5]      #           ['c', 'd', 'e']
a[2:-1]     #           ['c', 'd', 'e', 'f', 'g']
a[-3:-1]    #                          ['f', 'g']


# 슬라이싱은 start와 end 인덱스가 리스트의 경계를 벗어나도 적절하게 처리한다.
# 덕분에 입력 시퀀스에 대응해 처리할 최대 길이를 코드로 쉽게 설정할 수 있다.

first_twenty = a[20:]
last_twenty = a[:20]
# 에러가 발생하지 않는다.
# 반대로 인덱스를 직접 접근하면 에러가 발생한다.

a[20]  # Error!!


"""
슬라이싱의 결과는 완전히 새로운 리스트이다.
원본 리스트에 들어 있는 객체에 대한 참조는 유지되지만,
슬라이스 결과를 수정해도 원본에는 영향을 미치지 않는다.
"""

b = a[:4]
print('Before:   ', b)  # ['e', 'f', 'g', 'h']
b[1] = 99
print('After :   ', b)  # ['e', 99 , 'g', 'h']
print('No Change:', a)  # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

# a는 변하지 않았다.


"""
슬라이스를 할당에 사용하면(좌변에 두면) 원본 리스트에서 지정한 범위를 대체한다.
tuple 할당과 달리 슬라이스 할당의 길이는 달라도 되며,
할당받은 슬라이스의 앞뒤 값은 유지된다.
리스트는 새로 들어온 값에 맞춰 늘어나거나 줄어든다.
"""

print('Before : ', a)  # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
a[2:7] = [99, 24, 14]
print('After  : ', a)  # ['a', 'b', 99, 22, 14, 'h']


# 시작과 끝 인덱스를 모두 생략하고 슬라이스하면 원본의 복사본을 얻는다.
b = a[:]
assert b == a and b is not a
# b와 a가 내용이 같지만 서로 다른 객체임을 확인하는 assert문이다.

# 슬라이스에 시작과 끝 인덱스를 지정하지 않고 할당하면(새 리스트를 할당하지 않고)
# 슬라이스의 전체 내용을 참조 대상의 복사본으로 대체한다.

b = a
print('Before', a)  # ['a', 'b', 99, 22, 14, 'h']
a[:] = [101, 102, 103]
assert a is b
print('After ', a)  # [101, 102, 103]

"""
만약 a[:]가 아닌 a = [101, 102, 103] 이렇게 했다면,
a가 가리키는 리스트 객체가 바뀌어 a와 b는 달라질 것이다.

그런데 a[:]를 할당에 사용하면 가리키는 객체 자체의 값이 변한다.
"""


"""
핵심 정리 :
    너무 장황하게 하지 말자. start에 0을 쓰거나 end에 시퀀스의 길이를 설정하지 말자.
    슬라이싱은 범위를 벗어난 인덱스를 허용하므로, a[:1000000]와 같은 것도 에러가 나지 않는다.
    list 슬라이스에 할당하면(왼쪽에 두면) 원본 시퀀스의 지정한 범위를 대체한다.

"""
