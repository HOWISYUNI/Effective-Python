## Better Way 17. 인수를 순회할 때는 방어적으로 하자

#### 66쪽

* Created : 2016/09/02
* Modified: 2019/05/13

<br>

## 1. 이터레이터 사용 시의 주의점

파라미터로 리스트를 받는 함수에서 리스트를 여러 번 순회해야 할 때가 있다. 예를 들어, 일련의 정수 배열을 입력 받아 각 원소를 총합에 대한 각 원소의 비율(%)로 표현하는 정규화(normalize) 연산이 필요하다고 하자. 이 간단한 함수는 다음과 같이 정의할 수 있을 것이다.

```python
def normalize(numbers):
    total = sum(numbers)
    result = []

    for value in numbers:
        percent = 100 * value / total
        result.append(percent)
    return result


performances = [15, 35, 80]
percentages = normalize(performances)

>>> print(percentages)

[11.538461538461538, 26.923076923076923, 61.53846153846154]
```

_normalize_ 함수는 정수 배열을 입력 받아 총합에 대한 각자의 비율 퍼센트를 구한다.  

이 예제를 이번에는 데이터 과학적인 접근법으로 다가가보자. 입력 리스트가 덩그러니 주어지는 것이 아닌, 파일에서 각 원소를 한 줄씩 읽어서 정규화하는 식이다.

이를 위해 파일에서 정수 한 줄씩(예를 들어 지역별 매출액일 수 있겠다) 반환하는 제너레이터 함수를 만들어보자.


```python
def read_data(path):
    with open(path) as f:
        for line in f:
            yield int(line)
```

경로에 적절한 파일이 있으면 한 줄씩 정수로 변환해 반환하는 제너레이터이다. **이 함수에서 반환된 제너레이터를 _normalize_ 함수에 집어넣으면 정규화가 가능할 것이라 생각할 수 있는데, 놀랍게도 아무값도 생성되지 않는다.**

```python
it = read_data('data') # 테스트를 위해 데이터 파일을 만들었다.
percentages = normalize(it)

>>> print(percentages)

[]
```

왜 이런 결과가 나왔을까? _normalize_ 함수를 다시 살펴보자.

```python
def normalize(it):
    total = sum(it) # 1.
    result = []

    for value in it: # 2.
        percent = 100 * value / total
        result.append(percent)
    return result
```

함수 인자의 이름을 'numbers'에서 'it'로만 바꿨고 나머지는 같다. 알다시피, **이터레이터는 반환하도록 정해진 값을 모두 소진하면 그 다음부터는 _next_ 를 통해 호출해도 _StopIteration_ 만을 반환한다.**

**위의 코드에서 1번과 2번에서 모두 이터레이터에 대한 소진을 요구한다.** _sum_ 함수는 원소를 모두 호출한 뒤에 그 합을 구하고, for 반복문 또한 값을 모두 호출하기 때문이다. 그래서 _total_ 변수는 적절히 채워지는 반면, for 문은 실행조차 되지 않는다.

재밌는 건, **위와 같은 상황에서 에러가 반환되지 않는다는 것이다.** 그래서 결과가 없는 이터레이터와 결과가 있었지만 이미 소진한 이터레이터의 차이를 구별하는 건 다른 API를 통해야 한다. **이런 애매함 때문에 이터레이터를 사용해야 하는 경우에 입력 인자에 대한 방어적인 검증 절차가 필요해진다.**

<br>

이런 상황에서 택할 수 있는 가장 일반적인 해결책은 입력된 이터레이터를 명시적으로 리스트화해서 저장하는 방법이다.


```python
def normalize(numbers):
    numbers = list(numbers)  # !! 리스트화해서 저장
    total = sum(numbers)
    result = []

    for value in numbers:
        percent = 100 * value / total
        result.append(percent)
    return result
```

이 방법은 이전 정규화 함수에 비해 입력에 대해 보다 방어적이라고 평가할 수 있다. 입력이 일반 자료구조일 때뿐 아니라 이터레이터, 제너레이터 등일 때도 문제없이 작동하기 때문이다.  

하지만 이 방법은 치명적인 단점이 있으니, **이터레이터를 리스트화하는 과정에서 데이터양이 많다면 프로그램의 메모리가 고갈되어 동작을 멈출 수 있다는 점이다.** 우리가 일반적으로 다루는 작은 파일에서야 물론 문제없지만, 대용량 데이터 등을 다룰 때는 이런 액션은 필시 피해야 한다.(참고로 이 문제는 내가 기술면접 보러 가서도 받은 질문이니 참고하자)  

이번 장은 이런 문제에 대해 리스트화하지 않고 문제를 해결하는 방법에 대해 다룬다. 다음 두 장에서 서로 다른 해결책을 찾아보자.

<br>


## 2. 해결책 1: 이터레이터 생성 함수 자체를 입력으로 받기

기존 코드를 많이 바꾸지 않고 해결할 수 있는 한 가지 방법은 기존 함수가 이터레이터를 입력을 받았다면, **대신 이터레이터 생성 함수 자체를 입력으로 받아 필요할 때마다 이터레이터를 만들어 쓰는 것이다.**


```python
def normalize(iter_func):
    total = sum(iter_func())
    result = []

    for value in iter_func():
        percent = 100 * value / total
        result.append(percent)
    return result
```

새로 작성한 정규화 함수는 이터레이터 생성 함수를 입력으로 받아 소진이 필요할 때마다 새로운 이터레이터를 만든다. **위 함수를 사용하기 위해서는 아까 사용한 _read\_data_ 함수를 반환하는 람다 함수를 사용하면 된다.**


```python
percentages = normalize(lambda: read_data(path))
```

여기까지가 이해되는가? 여기까지 이해하면 이 장에 대한 감을 잡고 있고, Iterator, Generator에 대한 기본적인 이해는 되고 있다는 것을 의미한다. 헷갈린다면, 위에서부터 한 번 다시 보는 것을 추천한다.

일단 이 코드는 잘 작동한다. 하지만 이렇게 호출시마다 람다 함수를 넣어주는 방식이 세련되지 못하고 딱 봐도 가독성이 떨어진다. 이에 대한 보다 바람직한 해결책은 `이터레이터 프로토콜(Iterator Protocol)`을 구현한 새 컨테이터 클래스를 제공하는 것이다.


<br>

## 3. 해결책 2: Iterator Protocol을 구현한 컨테이터 클래스 사용

**이터레이터 프로토콜은 순회할 수 있는 Iterable에서 이터레이터를 생성하고 원소를 하나씩 호출하는 규칙에 대한 정의다. 모든 사전 정의된 이터레이터들은 이 프로토콜을 지키며, Custom 이터레이터를 만들어 사용하고 싶으면 이 프로토콜을 지켜야 한다.**  

예를 들어 **파이썬에서 `for n in numbers` 와 같은 문장을 만나면 내부적으로는 _iter(numbers)_ 를 호출해 이터레이터를 만든다. _iter_ 함수는 특별한 함수인 _numbers.\_\_iter\_\__ 메소드를 호출한다.**  

그리고 **생성된 이터레이터에 _next_ 함수를 계속 호출해 값을 순회한다. _next_ 함수는 또 특별한 함수인 _numbers.\_\_next\_\__ 메소드를 호출하게 된다.**

**이터레이터에 대한 이런 특징은 각 기능이 이터레이터 프로토콜을 준수하기 때문에 가능하다.** 이터레이터 생성과 사용에 관련한 이터레이터 프로토콜의 주요 내용은 다음과 같다.

* **Iterable에 _iter_ 함수를 호출하면(iterable.\_\_iter\_\_ 메소드를 호출하면) 이터레이터를 반환한다.**
* **Iterator에 _iter_ 를 호출하면 자기 자신을 반환한다. 복사본이 아니다.**
* **Iterator에 _next_ 함수를 호출하면(iterator.\_\_next\_\_ 메소드를 호출하면) 원소를 하나씩 호출한다. 모든 원소를 소진하면 _StopIteration_ 에러를 일으킨다.**

**이 규칙을 지키면 나만의 커스텀 이터레이터, 제너레이터도 얼마든지 만들 수 있다.** 이번 해결책은 나만의 커스텀 이터레이터 컨테이너 클래스를 사용하는 방법이다.

<br>

**나만의 커스텀 이터레이터 컨테이너를 만드는 쉬운 방법은 클래스의 \_\_iter\_\_ 메소드를 제너레이터로 구현하는 것이다.** 이번에는 아까 만든 _read\_data_ 함수를 컨테이너 클래스로 만들어보자.

```python
class ReadData:
    def __init__(self, path):
        self.path = path

    def __iter__(self):
        with open(self.path) as f:
            for line in f:
                yield int(line)
```

위 클래스는 \_\_iter\_\_ 메소드를 구현하고 있는데 _yield_ 문을 사용하는 제너레이터이다. 그러면 **인스턴에 _iter_ 함수를 사용하면 제너레이터가 반환되고 _next_ 로 소진될 때까지 원소를 순회한다는 강한 확신을 가질 수 있다.** 즉, 저 클래스는 이터레이터 프로토콜을 준수하는 이터레이터 컨테이너 클래스인 것이다.

새로 정의한 컨테이터 타입은 원래의 정규화 함수에 수정을 가하지 않아도 제대로 동작한다.

```python
data_container = ReadData(path)
percentages = normalize(data_container)

>>> print(percentages)

[11.538461538461538, 26.923076923076923, 61.53846153846154]
```

저 클래스 코드가 동작하는 이유는 정규화 함수에서 _sum_ 과 _for_ 를 통과할 때마다 새로 _iter_ 함수를 호출해서 매번 새로운 제너레이터를 사용하기 때문이다. 본질적으로 첫 번째 해결책과 같은 이유이다. 다만 첫 번째처럼 람다 함수를 쓰지 않아도 되기에 더 깔끔하다.


<br>

## 4. 정규화 함수에서 방어적으로 인자 받기

이전 두 장에서 같은 이터레이터를 두 번 이상 쓰는 코드에 대한 해결책을 알아보았다. 이 문제는 한 이터레이터가 입력을 모두 순회하면 재사용할 수 없다는 점에서 기인한다. 우리는 데이터를 읽는 코드를 수정함으로써 같은 데이터에 대한 여러 이터레이터를 사용하는 정규화 함수를 문제없이 쓸 수 있었다.

이제 마지막으로, 정규화 함수의 입력에 대한 검증을 넣자. 확인했다시피 정규화 함수는 다양한 인자를 받을 수 있는데, 인자가 이터레이터면 의도한 대로 동작하지 않을 것이다. 다시 말해, **정규화 함수가 이터레이터를 받지 않도록 해야 한다.**

어떻게 인자가 이터레이터인지 확인할 수 있을까? _isinstance_ 와 같은 함수를 쓸 수도 있을 것이다. 하지만 더 간단한 해결책이 있다. 앞서 살펴본 이터레이터 프로토콜 항목 중에서 '**이터레이터에 _iter_ 함수를 호출하면 자기 자신을 반환한다**'가 기억나는지? 그것을 사용하자.

```python
def normalize_defensive(numbers):
    if iter(numbers) is iter(numbers): # 이터레이터면 True가 나온다!
        raise TypeError("Must supply a container")

    result = []

    for value in iter_func():
        percent = 100 * value / total
        result.append(percent)
    return result
```

만약 _numbers_ 가 리스트 같은 이터러블이거나, 앞서 만든 이터레이터 컨테이터였다면 두 번의 _iter_ 에서 서로 다른 결과물이 나왔을 것이다. 하지만 이터레이터라면, 이터레이터 프로토콜에 의해 _iter_ 를 몇 번을 실행하든 자기 자신이 반환될 것이다. 따라서 둘이 같다면 에러를 반환하게 할 수 있다.

**이터레이터를 사용할 때는 이렇게 인자에 대한 순회를 방어적으로 해서, 디버깅이 어려운 소진 관련 문제를 회피하는 방법을 고려해볼만 하다.**

<br>

## 5. 핵심 정리

* 입력 인수를 여러 번 순회하는 함수를 작성할 때 주의하자. 입력 인수가 이터레이터라면 이상하게 동작해서 값을 잃어버릴 수 있다.  
* 파이썬의 이터레이터 프로토콜(Iterator Protocol)은 컨테이너와 이터레이터가 내장 함수 _iter_, _next_ 와 for 반복문 및 관련 표현식과 상호작용하는 방법을 정의한다.  
* \_\_iter\_\_ 메서드를 제너레이터로 구현하면, 자신만의 이터러블 컨테이터 타입을 쉽게 정의할 수 있다.  
* 어떤 값에 _iter_ 값을 두 번 호출했을 때 같은 결과가 나오고 _next_ 내장 함수로 전진시킬 수 있다면 그 값은 컨테이너가 아닌 이터레이터다.
